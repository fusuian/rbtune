#!/usr/bin/env ruby

require "selenium-webdriver"
require "ffmpeg"
require "optparse"
require "pp"

uri = "https://www.nhk.or.jp/radio/ondemand/"

$show_program_mode = true

opt = OptionParser.new
Version = Rbradi::VERSION
opt.on('-r', '--rec', 'Download programs') {|v| $show_program_mode = false}
opt.banner += ' [program] [episode]'
opt.banner += "\n\nらじる★らじるの聴き逃しから、番組名とサブタイトルを指定してリストアップ(またはダウンロード)する\n
"

# 番組一覧情報を得る
def search_program(driver)
  elements = driver.find_elements(:css, 'div#ondemandList a')
  elements.map { |e|
    h3, h3span, desc, station = ['h3', 'p', 'p span'].map { |css|
      begin
        el = e.find_element(:css, css)
        el.text
      rescue Selenium::WebDriver::Error::NoSuchElementError
        nil
      end
    }
    desc.sub! /#{station}/, '' if station
    {title: h3, station: station, text: desc, element: e}
  }
end

# プレーヤーページから番組情報を得る
def player_property(el, driver)
  # 番組ページを開く
  mh = driver.window_handle
  driver.switch_to.window mh if driver.window_handle != mh
  element_title = el.find_element(:css, 'h3').text
  el.find_element(:css, 'a').click
  wait = Selenium::WebDriver::Wait.new(timeout: 10)
  wait.until { driver.window_handles.length > 1 && driver.window_handles[1] }
  handle = driver.window_handles[1]
  driver.switch_to.window handle
  wait.until { driver.find_element(:class, 'nol_audio_player').displayed? }

  player = driver.find_element(:class, 'nol_audio_player')
  data_aa = player.attribute('data-aa')
  type, title, station, s, stoe = data_aa.split(';')
  starttime, endtime = stoe.split('_')
  prop = {
    text: element_title,
    title: title,
    station: station,
    start_time: starttime,
    end_time: endtime,
    url: player.attribute('data-hlsurl'),
    aa: data_aa,
  }
  driver.switch_to.window mh
  prop
end


# ffmpeg でエピソードをダウンロードする
def rec(url, filename)
  ffmpeg           = FFMpeg.new
  ffmpeg['i']      = url # input stream
  ffmpeg['acodec'] = 'copy'  # acodecオプションはiオプションのあとに置かないとエラー
  ffmpeg.rec filename
end


# サブタイトル情報を表示する
def show_episode(el)
  episode = el.find_element(:class, 'title').text
  d1 = el.find_element(:class, 'd1').text
  d2 = el.find_element(:class, 'd2').text
  puts "** #{episode}"
  puts "    #{d1}"
  puts "    #{d2}"
  puts
end


# サブタイトルの一覧を表示する
def list_episodes(elements)
  elements.each do |el|
    show_episode el
  end
end

# 番組ページを開いてエピソードのリストを得る
def episodes_from_program(prog, driver)
  driver.navigate.to prog[:element].attribute('href')
  wait = Selenium::WebDriver::Wait.new(timeout: 10)
  wait.until { driver.find_element(:class_name, 'block') }
  driver.find_elements(:class_name, 'block li')
end


# 番組一覧を表示する
def list_programs(programs)
  programs.each do |prog|
    # p prog
    title = prog[:title].sub(/\n/, ': ')
    puts "* #{title}"
  end
end


# サブタイトルを録音する
def rec_episodes(elements, driver)
  elements.each do |el|
    prop = player_property el, driver
    puts "downloading: #{prop[:title]}..."
    rec prop[:url], "#{prop[:title]}.mp4"
  end
end

opt.parse! ARGV
title, episode = ARGV

begin
  driver = Selenium::WebDriver.for :firefox
  driver.navigate.to uri
  wait = Selenium::WebDriver::Wait.new(timeout: 10)
  wait.until { driver.find_element(:id, 'ondemand').displayed? }
  programs = search_program driver

  if title
    programs.filter! {|prog| prog[:title] =~ /#{title}/ }
    programs.each do |prog|
      puts "* #{prog[:title]}"
      driver2 = Selenium::WebDriver.for :firefox
      elements = episodes_from_program prog, driver2
      elements.filter! {|e| e.text =~ /#{episode}/} if episode
      if $show_program_mode
        list_episodes elements
      else
        rec_episodes elements, driver2
      end
      driver2.quit
    end
  else
    list_programs programs
  end

rescue Selenium::WebDriver::Error::SessionNotCreatedError
  $stderr.puts $!
ensure
  driver && driver.quit
end